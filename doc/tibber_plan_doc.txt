MCU:
I will go with STM32 F - series. There are low power, robust, reasonable priced MCU-s in that series.
I do not have hardware at home at the moment, so my solution will be without MCU specific code.

Environment:
I chose C language with cMake, Unity test and cMock (with Ceedling build system in Ruby environment). 
I could integrate it to VS Code.
For STM32 specific code, I would use EMbitz IDE or STM-Cube. 
Depends, if we want to use CubeÂ´s HAL or the direct register accessing defines in ST libraries.

FreeRTOS:
- Tx and Rx will be done in uart interrupt
- FreeRTOS task will go to sleep (Delay or Suspend) after Tx and Rx started
- Callback will wake up the task at the end of the Tx and Rx transactions
- Waking up with notification, it is fast and low consumption and only this task will receive it
- Other tasks can run, because communication is nonblocking. No polling is needed
- Timeout needs to be set. 
----Either in FreeRTOS level (Delay) or watchdog or some other timer during the communication

Running on battery powered device:
- Minimize heavy calculations and processor usage
----Just do the minimal data parsing. Converting text to numbers can happen on the server/computer
----Send short data to server/computer
----No polling, using interrupts instead
----Consider saving the extract of the data to persistent memory. 
--------Handheld device can be powered off (or go to low power mode), 
--------data will be kept and transferred in bulk to server. 
----Optimize code.

Format:
A string will be sent, then the computer can parse it properly.
{ID:[id];L1:[volts]:[amps];L2:[volts]:[amps];L3:[volts]:[amps];TS:[timestamp];}
for example:
"{ID:LGZ4ZMF100AC.M29CRLF;L1:231:00.000;L2:231:00.000;L3:231:00.000;TS:59-59-23-18-01-2024;}"
---timestamp is not necessary if it is a large overhead

Error handling:
- checking pointers against NULL
- error message to the task OR functions always return error code...

TX and RX:
- timeout should be set
- RX can be monitored with a timer





